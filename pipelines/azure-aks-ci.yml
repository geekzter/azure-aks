parameters:
- name: workspace
  displayName: Pipeline Environment / Terraform Workspace
  type: string
  default: ci
  values:
  - ci
  - ci1
  - ci2
  - ci3
- name: inherit
  displayName: Inherit state
  type: boolean
  default: false
- name: deploy
  displayName: Deploy applications
  type: boolean
  default: true
- name: destroy
  displayName: Destroy infrastructure
  type: boolean
  default: true

trigger: none

pr:
  branches:
    include:
    - '*'
  paths:
    exclude:
    - '.devcontainer/**'  
    - 'visuals/**'  
    - '*.md'  

schedules:
- cron: '0 1 * * *'
  displayName: 'Nightly build (UTC)'
  # Run if there are no changes
  always: 'true'
  branches:
    include:
    - main

variables:
- group: 'aks-ci'
- group: 'pipeline'

- name: 'jobTimeOutMinutes'
  value: 180
- name: 'repository'
  value: 'azure-aks'

- name: AZURE_EXTENSION_USE_DYNAMIC_INSTALL
  value: 'yes_without_prompt'
- name: 'TF_IN_AUTOMATION'
  value: 'true'
- name: 'TF_INPUT'
  value: 0
- name: 'TF_WORKSPACE'
  value: ${{ parameters.workspace }}
- name: 'manifestDirectory'
  value: '$(Build.SourcesDirectory)/manifests'
- name: 'scriptDirectory'
  value: '$(Build.SourcesDirectory)/scripts'
- name: 'terraformDirectory'
  value: '$(Build.SourcesDirectory)/terraform'
# - name: 'TF_VAR_resource_suffix'
#   value: 'b$(Build.BuildId)'
- name: 'TF_VAR_run_id'
  value: '$(Build.BuildId)'

- name: 'resourceGroup' 
  value: 'k8s-$(TF_WORKSPACE)-$(TF_VAR_resource_suffix)'

jobs:
- job: 'Provision'
  displayName: 'Provision'
  condition: succeeded()
  timeoutInMinutes: $[ variables['jobTimeOutMinutes'] ]

  pool:
    name: '$(pool)'
    vmImage: $(vmImage)

  workspace:
    clean: all

  steps:
    - task: AzureCLI@2
      displayName: 'Gather Terraform settings'
      name: terraformConfig
      inputs:
        azureSubscription: '$(subscriptionConnection)'
        scriptType: pscore
        scriptLocation: inlineScript
        inlineScript: |
          # List environment variables
          Get-ChildItem -Path Env: -Recurse -Include ARM_*,AZURE_*,GEEKZTER_*,TF_* | Sort-Object -Property Name

          $terraformVersion = (Get-Content .terraform-version)
          Write-Host "##vso[task.setvariable variable=version;isOutput=true]${terraformVersion}"
        useGlobalConfig: true
        failOnStandardError: true
        workingDirectory: '$(terraformDirectory)'

    - task: TerraformInstaller@0
      displayName: 'Use preferred Terraform version'
      inputs:
        terraformVersion: '$(terraformConfig.version)'

    - ${{ if not(eq(parameters.inherit, true)) }}:
      - task: AzureCLI@2
        name: clear
        displayName: 'Remove resources from previous runs'
        inputs:
          azureSubscription: '$(subscriptionConnection)'
          scriptType: pscore
          scriptLocation: inlineScript
          inlineScript: |
            # Remove VNet peerings
            if ($env:GEEKZTER_AGENT_VIRTUAL_NETWORK_ID) {
              $peeringIDs = $(az network vnet show --ids $env:GEEKZTER_AGENT_VIRTUAL_NETWORK_ID --query "virtualNetworkPeerings[?starts_with(name,'k8s-${env:TF_WORKSPACE}-')].id" -o tsv 2>$null)
              if ($peeringIDs) {
                Write-Host "Removing virtual network peerings `"${peeringIDs}`"..."
                &{ # az writes information to stderr
                  $ErrorActionPreference = 'SilentlyContinue'
                  az resource delete --ids $peeringIDs 2>&1
                }
              } else {
                Write-Host "No virtual network peerings to remove"
              }
            }
          useGlobalConfig: true
          failOnStandardError: true
          workingDirectory: '$(terraformDirectory)'

    - task: TerraformCLI@0
      displayName: 'Terraform init'
      inputs:
        command: 'init'
        workingDirectory: '$(terraformDirectory)'
        backendType: 'azurerm'
        backendServiceArm: '$(subscriptionConnection)'
        backendAzureRmResourceGroupName: '$(TF_STATE_RESOURCE_GROUP_NAME)'
        backendAzureRmStorageAccountName: '$(TF_STATE_STORAGE_ACCOUNT_NAME)'
        backendAzureRmContainerName: '$(TF_STATE_CONTAINER_NAME)'
        backendAzureRmKey: 'terraform.tfstate'
        allowTelemetryCollection: true

    - task: AzureCLI@2
      displayName: 'Apply infrastructure with Terraform'
      name: apply
      inputs:
        azureSubscription: '$(subscriptionConnection)'
        scriptType: pscore
        scriptLocation: inlineScript
        inlineScript: |
          # Propagate pipeline Service Principal as Terraform variables
          $env:ARM_CLIENT_ID       ??= $env:servicePrincipalId
          $env:ARM_CLIENT_SECRET   ??= $env:servicePrincipalKey
          $env:ARM_TENANT_ID       ??= $env:tenantId
          # Get from Azure CLI context
          $env:ARM_TENANT_ID       ??= $(az account show --query tenantId -o tsv)
          $env:ARM_SUBSCRIPTION_ID ??= $(az account show --query id -o tsv)              
          
          # Get Agent VNet information
          $env:TF_VAR_peer_network_id = $env:GEEKZTER_AGENT_VIRTUAL_NETWORK_ID

          # Convert uppercased Terraform environment variables to their original casing expeted by Terraform
          foreach ($tfvar in $(Get-ChildItem -Path Env: -Recurse -Include TF_VAR_*)) {
            $upperCaseName = $tfvar.Name + "_UC"
            $properCaseName = $tfvar.Name.Substring(0,7) + $tfvar.Name.Substring(7).ToLowerInvariant()
            $null = New-Item -Path env:$upperCaseName -Value $tfVar.Value
            Remove-Item -Path env:$($tfvar.Name)
            $null = New-Item -Path env:$properCaseName -Value $tfVar.Value
            Set-Item -Path env:$upperCaseName -Value $null
          } 
          # List environment variables
          Get-ChildItem -Path Env: -Recurse -Include ARM_*,AZURE_*,GEEKZTER_*,TF_* | Sort-Object -Property Name

          # Run Terraform
          terraform version
          terraform apply -auto-approve

          # Export Terraform output as task output
          $terraformOutput = terraform output -json | ConvertFrom-Json -AsHashtable
          foreach ($outputVariable in $terraformOutput.keys) {
              $value = $terraformOutput[$outputVariable].value
              if ($value) {
                  Write-Host "##vso[task.setvariable variable=$outputVariable;isOutput=true]$value"
              }
          }            
        addSpnToEnvironment: true
        useGlobalConfig: true
        failOnStandardError: true
        powerShellIgnoreLASTEXITCODE: false
        workingDirectory: '$(terraformDirectory)'

    - task: KubectlInstaller@0
      displayName: 'Install kubectl'
      inputs:
        kubectlVersion: 'latest'

    - task: Kubernetes@1
      displayName: 'Apply ASP.NET App manifest with kubectl'
      inputs:
        connectionType: 'Azure Resource Manager'
        azureSubscriptionEndpoint: '$(subscriptionConnection)'
        azureResourceGroup: '$(apply.resource_group)'
        kubernetesCluster: '$(apply.aks_name)'
        useClusterAdmin: true
        command: 'apply'
        useConfigurationFile: true
        configuration: '$(manifestDirectory)/aspnetapp.yaml'
        secretType: 'generic'
        
    - task: Kubernetes@1
      displayName: 'Apply Voting App manifest with kubectl'
      inputs:
        connectionType: 'Azure Resource Manager'
        azureSubscriptionEndpoint: '$(subscriptionConnection)'
        azureResourceGroup: '$(apply.resource_group)'
        kubernetesCluster: '$(apply.aks_name)'
        useClusterAdmin: true
        command: 'apply'
        useConfigurationFile: true
        configuration: '$(manifestDirectory)/internal-vote.yaml'
        secretType: 'generic'

    - ${{ if eq(parameters.deploy, true) }}:
      - task: AzureCLI@2
        displayName: 'Test applications'
        inputs:
          azureSubscription: '$(subscriptionConnection)'
          scriptType: pscore
          scriptLocation: inlineScript
          inlineScript: |
            # Propagate pipeline Service Principal as Terraform variables
            $env:ARM_CLIENT_ID       ??= $env:servicePrincipalId
            $env:ARM_CLIENT_SECRET   ??= $env:servicePrincipalKey
            $env:ARM_TENANT_ID       ??= $env:tenantId
            # Get from Azure CLI context
            $env:ARM_TENANT_ID       ??= $(az account show --query tenantId -o tsv)
            $env:ARM_SUBSCRIPTION_ID ??= $(az account show --query id -o tsv)              

            ./deploy_app.ps1
          addSpnToEnvironment: true
          useGlobalConfig: true
          failOnStandardError: true
          powerShellIgnoreLASTEXITCODE: false
          workingDirectory: '$(scriptDirectory)'
        env:
          KUBECONFIG: '$(apply.kube_config)'

    - ${{ if eq(parameters.destroy, true) }}:
      - task: AzureCLI@2
        displayName: 'Destroy infrastructure with Terraform'
        inputs:
          azureSubscription: '$(subscriptionConnection)'
          scriptType: pscore
          scriptLocation: inlineScript
          inlineScript: |
            # Propagate pipeline Service Principal as Terraform variables
            $env:ARM_CLIENT_ID       ??= $env:servicePrincipalId
            $env:ARM_CLIENT_SECRET   ??= $env:servicePrincipalKey
            $env:ARM_TENANT_ID       ??= $env:tenantId
            # Get from Azure CLI context
            $env:ARM_TENANT_ID       ??= $(az account show --query tenantId -o tsv)
            $env:ARM_SUBSCRIPTION_ID ??= $(az account show --query id -o tsv)              
            
            terraform version
            terraform destroy -auto-approve
          addSpnToEnvironment: true
          useGlobalConfig: true
          failOnStandardError: true
          powerShellIgnoreLASTEXITCODE: false
          workingDirectory: '$(terraformDirectory)'

    - ${{ if eq(parameters.destroy, true) }}:
      - task: AzureCLI@2
        name: teardown
        displayName: 'Tear down remaining resources'
        condition: always()
        enabled: ${{ parameters.destroy }}
        inputs:
          azureSubscription: '$(subscriptionConnection)'
          scriptType: pscore
          scriptLocation: inlineScript
          inlineScript: |
            $ErrorActionPreference = "Continue" # Continue to remove resources if remove by resoyrce group fails
            # Build JMESPath expression
            $tagQuery = "[?tags.repository == '$(repository)' && tags.workspace == '${env:TF_WORKSPACE}' && tags.runid == '$(Build.BuildId)' && properties.provisioningState != 'Deleting'].id"
            Write-Host "Removing resources identified by `"$tagQuery`"..."

            # Remove resource groups
            $resourceGroupIDs = $(az group list --query "${tagQuery}" -o tsv)
            if ($resourceGroupIDs) {
              Write-Host "Removing resource group(s) `"${resourceGroupIDs}`"..."
              &{ # az writes information to stderr
                $ErrorActionPreference = 'SilentlyContinue'
                az resource delete --ids $resourceGroupIDs 2>&1
              }
            } else {
              Write-Host "No resource groups to remove"
            }

            # Remove (remaining) resources
            $ErrorActionPreference = "Stop" # Don't clear workspace if next step fails
            $resourceIDs = $(az resource list --query "${tagQuery}" -o tsv)
            if ($resourceIDs) {
              Write-Host "Removing resources `"${resourceIDs}`"..."
              &{ # az writes information to stderr
                $ErrorActionPreference = 'SilentlyContinue'
                az resource delete --ids $resourceIDs 2>&1
              }
            } else {
              Write-Host "No resources to remove"
            }

            # Remove VNet peerings
            if ($env:GEEKZTER_AGENT_VIRTUAL_NETWORK_ID) {
              $peeringIDs = $(az network vnet show --ids $env:GEEKZTER_AGENT_VIRTUAL_NETWORK_ID --query "virtualNetworkPeerings[?starts_with(name,'k8s-${env:TF_WORKSPACE}-')].id" -o tsv 2>$null)
              if ($peeringIDs) {
                Write-Host "Removing virtual network peerings `"${peeringIDs}`"..."
                &{ # az writes information to stderr
                  $ErrorActionPreference = 'SilentlyContinue'
                  az resource delete --ids $peeringIDs 2>&1
                }
              } else {
                Write-Host "No virtual network peerings to remove"
              }
            }

            # Clean up Terraform state
            # Propagate pipeline Service Principal as Terraform variables
            $env:ARM_CLIENT_ID       ??= $env:servicePrincipalId
            $env:ARM_CLIENT_SECRET   ??= $env:servicePrincipalKey
            $env:ARM_TENANT_ID       ??= $env:tenantId
            # Get from Azure CLI context
            $env:ARM_TENANT_ID       ??= $(az account show --query tenantId -o tsv)
            $env:ARM_SUBSCRIPTION_ID ??= $(az account show --query id -o tsv)
            Copy-Item backend.tf.sample backend.tf
            terraform version
            terraform init -reconfigure `
                           -backend-config="resource_group_name=$(TF_STATE_RESOURCE_GROUP_NAME)" `
                           -backend-config="storage_account_name=$(TF_STATE_STORAGE_ACCOUNT_NAME)" `
                           -backend-config="container_name=$(TF_STATE_CONTAINER_NAME)" 
            $terraformState = (terraform state pull | ConvertFrom-Json)
            if ($terraformState.resources) {
              Write-Host "Clearing Terraform state in workspace ${env:TF_WORKSPACE}..."
              $terraformState.outputs = New-Object PSObject # Empty output
              $terraformState.resources = @() # No resources
              $terraformState.serial++
              $terraformState | ConvertTo-Json | terraform state push -
            } else {
              Write-Host "No resources in Terraform state in workspace ${env:TF_WORKSPACE}..."
            }
            terraform state pull 
          addSpnToEnvironment: true
          useGlobalConfig: true
          failOnStandardError: true
          workingDirectory: '$(terraformDirectory)'